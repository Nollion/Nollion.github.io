<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JavaScript中的事件绑定与事件代理(事件委托)</title>
      <link href="/2019/11/02/event-delegation/"/>
      <url>/2019/11/02/event-delegation/</url>
      
        <content type="html"><![CDATA[<h2 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h2><p>　　在<code>JavaScript</code>中，有三种常用的事件绑定方式：<br>　　▪ 直接与<code>DOM</code>元素绑定：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"myButton"</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"点我"</span> <span class="attr">onclick</span>=<span class="string">"alert('普通事件1');"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>　　▪ 在<code>JavaScript</code>代码中绑定：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"myButton"</span>).onclick=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">'普通事件2'</span>);<span class="comment">//通过这种方式绑定的事件将会覆盖上面的 alert('普通事件1') 方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　▪ 绑定事件监听函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"myButton"</span>).addEventListener(<span class="string">'click'</span>, a); <span class="comment">// 通过这种方式不能用 onclick 要用 click</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"myButton"</span>).addEventListener(<span class="string">'click'</span>, b);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">'事件监听1'</span>); <span class="comment">//执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">'事件监听2'</span>); <span class="comment">//执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　更多事件，详见<code>MDN</code>:<a href="https://developer.mozilla.org/zh-CN/docs/Web/Events" target="_blank" rel="noopener">事件类型一览表</a> 或者菜鸟教程: <a href="https://www.runoob.com/jsref/dom-obj-event.html" target="_blank" rel="noopener">HTML DOM 事件对象</a> ；<br>　　关于<code>addEventListener()</code>：<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener" target="_blank" rel="noopener">EventTarget.addEventListener() - Web API 接口</a> ；</p><h2 id="事件代理-事件委托"><a href="#事件代理-事件委托" class="headerlink" title="事件代理(事件委托)"></a>事件代理(事件委托)</h2><p>　　<strong>事件代理</strong>又叫<strong>事件委托</strong>，其原理就是利用事件冒泡的原理，通过把事件添加到父元素或祖先元素上，触发执行效果。<br>　　举个不太严谨的例子：好比一群学生要上交登记表到行政办公室，然后学生都填好表后委托班主任统一交去行政办公室，让班主任代理去交(当然可以每个学生自行去交，但是效率相对较低)。<br><img alt data-src="https://img.alicdn.com/tfs/TB1ICA8ywHqK1RjSZFEXXcGMXXa-540-486.png" class="lozad"></p><h2 id="事件代理基本实现"><a href="#事件代理基本实现" class="headerlink" title="事件代理基本实现"></a>事件代理基本实现</h2><p>　　比如我们有这样的一个<code>HTML</code>需要我们对其里面的<code>li</code>标签进行绑定事件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"list"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  ......</span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>item n<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>　　我们来把<code>#list</code>下的<code>li</code>标签的事件代理委托到它的父层元素也就是<code>#list</code>上：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给父层元素绑定事件</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'list'</span>).addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 兼容性处理</span></span><br><span class="line">  <span class="keyword">var</span> event = e || <span class="built_in">window</span>.event;</span><br><span class="line">  <span class="keyword">var</span> target = event.target || event.srcElement;</span><br><span class="line">  <span class="comment">// 判断是否匹配目标元素</span></span><br><span class="line">  <span class="keyword">if</span> (target.nodeName.toLocaleLowerCase === <span class="string">'li'</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'the content is: '</span>, target.innerHTML);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>　　这就是一个简单的事件代理实现啦~</p><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>　　这里可能有一些值得思考的点：<br>　　▪ 父层代理的元素可能有多个，都需要绑定事件；<br>　　▪ 绑定的事件类型可能有多个，都需要绑定事件；<br>　　▪ 兼容性处理等；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param String parentSelector 选择器字符串, 用于过滤需要实现代理的父层元素，既事件需要被真正绑定之上</span></span><br><span class="line"><span class="comment"> * @param String targetSelector 选择器字符串, 用于过滤触发事件的选择器元素的后代，既我们需要被代理事件的元素</span></span><br><span class="line"><span class="comment"> * @param String events 一个或多个用空格分隔的事件类型和可选的命名空间，如 click 或 keydown.click</span></span><br><span class="line"><span class="comment"> * @param Function callback 代理事件响应的函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">eventDelegate</span> (<span class="params">parentSelector, targetSelector, events, callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 触发执行的函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">triFunction</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 兼容性处理</span></span><br><span class="line">    <span class="keyword">var</span> event = e || <span class="built_in">window</span>.event;</span><br><span class="line">    <span class="comment">// 获取到目标阶段指向的元素</span></span><br><span class="line">    <span class="keyword">var</span> target = event.target || event.srcElement;</span><br><span class="line">    <span class="comment">// 获取到代理事件的函数</span></span><br><span class="line">    <span class="keyword">var</span> currentTarget = event.currentTarget;</span><br><span class="line">    <span class="comment">// 处理 matches 的兼容性</span></span><br><span class="line">    <span class="keyword">if</span> (!Element.prototype.matches) &#123;</span><br><span class="line">      Element.prototype.matches =</span><br><span class="line">        Element.prototype.matchesSelector ||</span><br><span class="line">        Element.prototype.mozMatchesSelector ||</span><br><span class="line">        Element.prototype.msMatchesSelector ||</span><br><span class="line">        Element.prototype.oMatchesSelector ||</span><br><span class="line">        Element.prototype.webkitMatchesSelector ||</span><br><span class="line">        <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">var</span> matches = (<span class="keyword">this</span>.document || <span class="keyword">this</span>.ownerDocument).querySelectorAll(s),</span><br><span class="line">            i = matches.length;</span><br><span class="line">          <span class="keyword">while</span> (--i &gt;= <span class="number">0</span> &amp;&amp; matches.item(i) !== <span class="keyword">this</span>) &#123;&#125;</span><br><span class="line">          <span class="keyword">return</span> i &gt; <span class="number">-1</span>;            </span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历外层并且匹配</span></span><br><span class="line">    <span class="keyword">while</span> (target !== currentTarget) &#123;</span><br><span class="line">      <span class="comment">// 判断是否匹配到我们所需要的元素上</span></span><br><span class="line">      <span class="keyword">if</span> (target.matches(targetSelector)) &#123;</span><br><span class="line">        <span class="keyword">var</span> sTarget = target;</span><br><span class="line">        <span class="comment">// 执行绑定的函数，注意 this</span></span><br><span class="line">        callback.call(sTarget, <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>))</span><br><span class="line">      &#125;</span><br><span class="line">      target = target.parentNode;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果有多个事件的话需要全部一一绑定事件</span></span><br><span class="line">  events.split(<span class="string">'.'</span>).forEach(<span class="function"><span class="keyword">function</span> (<span class="params">evt</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 多个父层元素的话也需要一一绑定</span></span><br><span class="line">    <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">document</span>.querySelectorAll(parentSelector)).forEach(<span class="function"><span class="keyword">function</span> (<span class="params">$p</span>) </span>&#123;</span><br><span class="line">      $p.addEventListener(evt, triFunction);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　进行使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eventDelegate(&apos;#list&apos;, &apos;li&apos;, &apos;click&apos;, function () &#123; console.log(this); &#125;);</span><br></pre></td></tr></table></figure><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>　　1.提高<code>JavaScript</code>性能。事件代理比起事件分发（即一个<code>DOM</code>一个事件处理程序），可以显著的提高事件的处理速度，减少内存的占用。<br>　　2.动态的添加<code>DOM</code>元素，不需要因为元素的改动而修改事件绑定。</p><h2 id="局限"><a href="#局限" class="headerlink" title="局限"></a>局限</h2><p>　　当然，事件委托也是有一定局限性的；比如<code>focus</code>、<code>blur</code>之类的事件本身没有事件冒泡机制，所以无法代理；<code>mousemove</code>、<code>mouseout</code>这样的事件，虽然有事件冒泡，但是只能不断通过位置去计算定位，对性能消耗高，因此也是不适合于事件代理的；</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>　　适合用事件委托的事件：<code>click</code>，<code>mousedown</code>，<code>mouseup</code>，<code>keydown</code>，<code>keyup</code>，<code>keypress</code>。所有的鼠标事件中，只有<code>mouseenter</code>和<code>mouseleave</code>不冒泡，其他鼠标事件都是冒泡的。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><div class="note no-icon">            <p><a href="https://blog.csdn.net/AC_greener/article/details/78602422" target="_blank" rel="noopener">JavaScript事件绑定和事件监听的区别 - AC_greener的博客 - CSDN博客</a><br><a href="https://github.com/yonyouyc/blog/issues/25" target="_blank" rel="noopener">JS中的事件委托或是事件代理详解 · Issue #25 · yonyouyc/blog · GitHub</a><br><a href="https://bobscript.com/archives/292/" target="_blank" rel="noopener">mouseenter、mouseover；mouseleave、mouseout的区别 - BobScript</a></p>          </div>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> event-delegation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式速记</title>
      <link href="/2019/10/28/Learning-Regular-Expressions/"/>
      <url>/2019/10/28/Learning-Regular-Expressions/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>　　正则表达式是一种用来匹配字符串的强有力的方式，另外正则表达式也是对象。</p><div class="note no-icon">            <p>正则表达式的设计思想是用一种描述性的语言来给字符串定义一个规则，凡是符合规则的字符串，则认为其“匹配”了，否则，该字符串就是不合法的。</p>          </div><h2 id="创建RegExp"><a href="#创建RegExp" class="headerlink" title="创建RegExp"></a>创建RegExp</h2><p>　　<code>JavaScript</code>有两种方式创建一个正则表达式：<br>　　第一种方式是直接通过<code>/正则表达式/</code>写出来，第二种方式是通过<code>new RegExp (&#39;正则表达式&#39;)</code>创建一个<code>RegExp</code>对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> re1 = <span class="regexp">/ABC\-001/</span>;</span><br><span class="line"><span class="keyword">var</span> re2 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'ABC\\-001'</span>);</span><br><span class="line"><span class="comment">//两种写法是一样的</span></span><br><span class="line">re1; <span class="comment">// /ABC\-001/</span></span><br><span class="line">re2; <span class="comment">// /ABC\-001/</span></span><br></pre></td></tr></table></figure><p>　　注意，如果使用第二种写法，因为字符串的转义问题，字符串的两个<code>\\</code>实际上是一个<code>\</code>。<br>　　<font color="red">如何判断正则表达式是否匹配：</font></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="regexp">/^\d&#123;3&#125;\-\d&#123;3,8&#125;$/</span>;</span><br><span class="line">re.test(<span class="string">'010-12345'</span>); <span class="comment">// true</span></span><br><span class="line">re.test(<span class="string">'010-1234x'</span>); <span class="comment">// false</span></span><br><span class="line">re.test(<span class="string">'010 12345'</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>　　<code>RegExp</code>对象有两个实例方法，其中<code>test()</code>方法用于测试给定的字符串是否符合条件。<code>exec()</code>方法用于返回匹配结果。</p><h2 id="预定义简写"><a href="#预定义简写" class="headerlink" title="预定义简写"></a>预定义简写</h2><p>　　一些常见预定义的简写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">\d 匹配<span class="number">0</span><span class="number">-9</span>之间的任一数字，相当于[<span class="number">0</span><span class="number">-9</span>]。</span><br><span class="line">\D 匹配所有<span class="number">0</span><span class="number">-9</span>以外的字符，相当于[^<span class="number">0</span><span class="number">-9</span>]。</span><br><span class="line">\w 匹配任意的字母、数字和下划线，相当于[A-Za-z0<span class="number">-9</span>\_]。</span><br><span class="line">\W 除所有字母、数字和下划线以外的字符，相当于[^A-Za-z0<span class="number">-9</span>\_]。</span><br><span class="line">\s 匹配空格（包括换行符、制表符、空格符等），相等于[ \t\r\n\v\f]。</span><br><span class="line">\S 匹配非空格的字符，相当于[^ \t\r\n\v\f]。</span><br><span class="line">\b 匹配词的边界。</span><br><span class="line">\B 匹配非词边界，即在词的内部</span><br></pre></td></tr></table></figure><p>　　在正则表达式中，如果直接给出字符，就是精确匹配。如：<br>　　<code>&#39;00\d&#39;</code>可以匹配<code>&#39;007&#39;</code>，但无法匹配<code>&#39;00A&#39;</code>；<br>　　<code>&#39;\d\d\d&#39;</code>可以匹配<code>&#39;010&#39;</code>；<br>　　<code>&#39;\w\w&#39;</code>可以匹配<code>&#39;js&#39;</code>；<br>　　<code>.</code>可以匹配任意字符，所以：<br>　　<code>&#39;js.&#39;</code>可以匹配<code>&#39;jsp&#39;</code>、<code>&#39;jss&#39;</code>、<code>&#39;js!&#39;</code>等等。</p><h2 id="量词符规范"><a href="#量词符规范" class="headerlink" title="量词符规范"></a>量词符规范</h2><p>　　要匹配变长的字符，在正则表达式中，用<code>*</code>表示任意个字符（包括0个），用<code>+</code>表示至少一个字符，用<code>?</code>表示0个或1个字符，用<code>{n}</code>表示n个字符，用<code>{n,m}</code>表示n-m个字符：</p><div class="note no-icon">            <p>? 问号表示某个模式出现0次或1次，等同于{0, 1}。<br>* 星号表示某个模式出现0次或多次，等同于{0,}。<br>+ 加号表示某个模式出现1次或多次，等同于{1,}。</p>          </div><p>　　来看一个稍微复杂的例子：<code>\d{3}\s+\d{3,8}</code>。<br>　　从左到右解读一下：</p><p>　　1. <code>\d{3}</code>表示匹配3个数字，例如<code>&#39;010&#39;</code>；</p><p>　　2. <code>\s</code>可以匹配一个空格（也包括Tab等空白符），所以<code>\s+</code>表示至少有一个空格，例如匹配<code>&#39; &#39;</code>，<code>&#39;\t\t&#39;</code>等；</p><p>　　3. <code>\d{3,8}</code>表示3-8个数字，例如<code>&#39;1234567&#39;</code>。</p><p>　　综合起来，上面的正则表达式可以匹配以任意个空格隔开的带区号的电话号码。但仍然无法匹配<code>&#39;010 - 12345&#39;</code>，因为带有空格。所以我们需要更复杂的匹配方式。</p><h2 id="范围匹配"><a href="#范围匹配" class="headerlink" title="范围匹配"></a>范围匹配</h2><p>　　要做更精确地匹配，可以用<code>[]</code>表示范围，比如：<br>　　1. <code>[0-9a-zA-Z\_]+</code>可以匹配至少由一个数字、字母或者下划线组成的字符串，比如<code>&#39;a100&#39;</code>，<code>&#39;0_Z&#39;</code>，<code>&#39;js2015&#39;</code>等等；</p><p>　　2. <code>[a-zA-Z\_\$][0-9a-zA-Z\_\$]*</code>可以匹配由字母或下划线、$开头，后接任意个由一个数字、字母或者下划线、$组成的字符串，也就是<code>JavaScript</code>允许的变量名；</p><p>　　3. <code>[a-zA-Z\_\$][0-9a-zA-Z\_\$]{0, 19}</code>更精确地限制了变量的长度是<code>1-20</code>个字符（前面1个字符+后面最多<code>19</code>个字符）。</p><p>　　4. <code>A|B</code>可以匹配<code>A或B</code> ，所以<code>(J|j)ava(S|s)cript</code>可以匹配<code>&#39;JavaScript&#39;</code>、<code>&#39;Javascript&#39;</code>、<code>&#39;javaScript&#39;</code>或者<code>&#39;javascript&#39;</code>。</p><div class="note no-icon">            <p>　<code>^</code>表示行的开头，<code>^\d</code>表示必须以数字开头。<br>　<code>$</code>表示行的结束，<code>\d$</code>表示必须以数字结束。</p>          </div><h2 id="切分字符串"><a href="#切分字符串" class="headerlink" title="切分字符串"></a>切分字符串</h2><p>　　用正则表达式切分字符串与正常的切分字符串代码比较：<br>　　正常切分字符串：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'a b   c'</span>.split(<span class="string">' '</span>); </span><br><span class="line"><span class="comment">// ['a', 'b', '', '', 'c']</span></span><br><span class="line"><span class="comment">//无法识别连续的空格</span></span><br></pre></td></tr></table></figure><p>　　正则表达式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'a b   c'</span>.split(<span class="regexp">/\s+/</span>); </span><br><span class="line"><span class="comment">// ['a', 'b', 'c']</span></span><br><span class="line"><span class="comment">//可以识别空格进行正常分割</span></span><br></pre></td></tr></table></figure><p>　　加入<code>,</code>以及<code>;</code>试试:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'a,b;; c  d'</span>.split(<span class="regexp">/[\s\,\;]+/</span>);</span><br><span class="line"><span class="comment">// ['a', 'b', 'c', 'd']</span></span><br><span class="line"><span class="comment">// bingo!</span></span><br></pre></td></tr></table></figure><h2 id="提取分组"><a href="#提取分组" class="headerlink" title="提取分组"></a>提取分组</h2><p>　　除了简单地判断是否匹配之外，正则表达式还有提取子串的强大功能。用<code>()</code>表示的就是要提取的分组<code>(Group)</code>。比如：<br>　　<code>^(\d{3})-(\d{3,8})$</code>分别定义了两个组，可以直接从匹配的字符串中提取出区号和本地号码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="regexp">/^(\d&#123;3&#125;)-(\d&#123;3,8&#125;)$/</span>;</span><br><span class="line">re.exec(<span class="string">'010-12345'</span>); <span class="comment">// ['010-12345', '010', '12345']</span></span><br><span class="line">re.exec(<span class="string">'010 12345'</span>); <span class="comment">// null</span></span><br></pre></td></tr></table></figure><p>　　如果正则表达式中定义了组，就可以在<code>RegExp</code>对象上用<code>exec()</code>方法提取出子串来。<br>　　<code>exec()</code>方法在匹配成功后，会返回一个<code>Array</code>，第一个元素是正则表达式匹配到的整个字符串，后面的字符串表示匹配成功的子串。失败时返回<code>null</code>。<br>　　一个匹配时间的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="regexp">/^(0[0-9]|1[0-9]|2[0-3]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])$/</span>;</span><br><span class="line">re.exec(<span class="string">'19:05:30'</span>); <span class="comment">// ['19:05:30', '19', '05', '30']</span></span><br></pre></td></tr></table></figure><p>　　这个正则表达式可以直接识别合法的时间。但是有些时候，用正则表达式也无法做到完全验证，比如识别日期：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="regexp">/^(0[1-9]|1[0-2]|[0-9])-(0[1-9]|1[0-9]|2[0-9]|3[0-1]|[0-9])$/</span>;</span><br></pre></td></tr></table></figure><p>　　对于<code>&#39;2-30&#39;</code>，<code>&#39;4-31&#39;</code>这样的非法日期，用正则写出来非常困难，这时就需要程序配合识别了。<br>　　当然，常用的邮箱匹配不难：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="regexp">/^\w+\.?\w+\@\w+\.\w+$/</span>;</span><br></pre></td></tr></table></figure><h2 id="贪婪匹配"><a href="#贪婪匹配" class="headerlink" title="贪婪匹配"></a>贪婪匹配</h2><p>　　正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符。<br>　　如匹配出数字后面的<code>0</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="regexp">/^(\d+)(0*)$/</span>;</span><br><span class="line">re.exec(<span class="string">'102300'</span>); <span class="comment">// ['102300', '102300', '']</span></span><br></pre></td></tr></table></figure><p>　　由于<code>\d+</code>采用贪婪匹配，直接把后面的0全部匹配了，结果<code>0*</code>只能匹配空字符串了。<br>　　加个<code>?</code>就可以让<code>\d+</code>采用非贪婪匹配：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="regexp">/^(\d+?)(0*)$/</span>;</span><br><span class="line">re.exec(<span class="string">'102300'</span>); <span class="comment">// ['102300', '1023', '00']</span></span><br></pre></td></tr></table></figure><div class="note no-icon">            <p> *？：表示某个模式出现0次或多次，匹配时采用非贪婪模式。<br>+?：表示某个模式出现1次或多次，匹配时采用非贪婪模式。</p>          </div><h2 id="全局搜索"><a href="#全局搜索" class="headerlink" title="全局搜索"></a>全局搜索</h2><p>　　<code>JavaScript</code>的正则表达式还有几个特殊的标志，最常用的是<code>g</code>，表示全局匹配：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> r1 = <span class="regexp">/test/g</span>;</span><br><span class="line"><span class="comment">// 等价于:</span></span><br><span class="line"><span class="keyword">var</span> r2 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'test'</span>, <span class="string">'g'</span>);</span><br></pre></td></tr></table></figure><p>　　全局匹配可以多次执行<code>exec()</code>方法来搜索一个匹配的字符串。当我们指定<code>g</code>标志后，每次运行<code>exec()</code>，正则表达式本身会更新<code>lastIndex</code>属性，表示上次匹配到的最后索引：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'JavaScript, VBScript, JScript and ECMAScript'</span>;</span><br><span class="line"><span class="keyword">var</span> re=<span class="regexp">/[a-zA-Z]+Script/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用全局匹配:</span></span><br><span class="line">re.exec(s); <span class="comment">// ['JavaScript']</span></span><br><span class="line">re.lastIndex; <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">re.exec(s); <span class="comment">// ['VBScript']</span></span><br><span class="line">re.lastIndex; <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line">re.exec(s); <span class="comment">// ['JScript']</span></span><br><span class="line">re.lastIndex; <span class="comment">// 29</span></span><br><span class="line"></span><br><span class="line">re.exec(s); <span class="comment">// ['ECMAScript']</span></span><br><span class="line">re.lastIndex; <span class="comment">// 44</span></span><br><span class="line"></span><br><span class="line">re.exec(s); <span class="comment">// null，直到结束仍没有匹配到</span></span><br></pre></td></tr></table></figure><p>　　全局匹配类似搜索，因此不能使用<code>/^...$/</code>，那样只会最多匹配一次。</p><div class="note no-icon">            <p>　<code>i</code>修饰符。用于忽略字符串大小写。<br>　<code>m</code>修饰符。用于设置匹配为多行模式。<br>　<code>g</code>修饰符。用于全局匹配。</p>          </div><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>　　正则表达式非常强大，本文仅用于个人速记<code>JavaScript</code>正则表达式的一些规范及常用正则表达式，如有读者想进一步了解更多的有关正则表达式可去官方文档查看。　　　　　　</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> RegExp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7个实用的JavaScript技巧(译)</title>
      <link href="/2019/10/24/7-Useful-JavaScript-Tricks/"/>
      <url>/2019/10/24/7-Useful-JavaScript-Tricks/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>　　在社区看到分享，mark下。本文为自行理解下的译文。内容较简单，若有读者觉得翻译不好难以理解，可直接查看英文原文，或直接看代码部分。文章各一部分有拓展超链（暂未翻译），可点击查看相关内容。</p><div class="note no-icon">            <p>原文链接：<a href="https://davidwalsh.name/javascript-tricks" target="_blank" rel="noopener">7 Useful JavaScript Tricks</a></p>          </div><p>　　<strong><font color="red">以下为译文：</font></strong><br>　　和其他编程语言一样，<code>JavaScript</code>有着许多技巧来解决一些简单的、亦或是困难的任务。其中有大家所熟知的部分，但也有一些技巧可能超乎你的想象。现在让我们来看一下这七个你随即可用的 <code>JavaScript</code>小技巧！</p><h2 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h2><p>　　获取<a href="https://davidwalsh.name/array-unique" target="_blank" rel="noopener">数组的唯一值</a>可能比你想象中要简单：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> j = [...new <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>])]</span><br><span class="line">&gt;&gt; [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>　　我喜欢<code>(…)</code>和<code>Set</code>！</p><h2 id="数组配合布尔"><a href="#数组配合布尔" class="headerlink" title="数组配合布尔"></a>数组配合布尔</h2><p>　　要从一个数组中<a href="https://davidwalsh.name/array-boolean" target="_blank" rel="noopener">过滤falsy值</a> (0, undefined, null, false, etc.)，你或许不知道有这种技巧：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">myArray</span><br><span class="line">    .map(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// ... </span></span><br><span class="line">        <span class="comment">// 记得 return</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 清除错误的值</span></span><br><span class="line">    .filter(<span class="built_in">Boolean</span>);</span><br></pre></td></tr></table></figure><p>　　只需传递 Boolean 就能去除这些 falsy 值！</p><h2 id="创建一个空的对象"><a href="#创建一个空的对象" class="headerlink" title="创建一个空的对象"></a>创建一个空的对象</h2><p>　　当然，你可以使用创建一个似乎为空的对象{}，但实际上这样创建的对象还是有<code>__proto__</code>和<code>hasOwnProperty</code>以及其他对象的方法。但是，有一种方法可以<a href="https://davidwalsh.name/object-create-null" target="_blank" rel="noopener">创建一个纯“字典”对象</a>的方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dict = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// dict.__proto__ === "undefined"</span></span><br><span class="line"><span class="comment">// 不存在对象属性，除非添加它们</span></span><br></pre></td></tr></table></figure><p>　　这个对象上绝对没有你没有放入的键或方法！</p><h2 id="合并对象"><a href="#合并对象" class="headerlink" title="合并对象"></a>合并对象</h2><p>　　<code>JavaScript</code><a href="https://davidwalsh.name/merge-objects" target="_blank" rel="noopener">合并多个对象</a> 的需求一直存在，尤其是当我们创建带有选项的类和小部件时：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123; <span class="attr">name</span>: <span class="string">'David Walsh'</span>, <span class="attr">gender</span>: <span class="string">'Male'</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> tools = &#123; <span class="attr">computer</span>: <span class="string">'Mac'</span>, <span class="attr">editor</span>: <span class="string">'Atom'</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> attributes = &#123; <span class="attr">handsomeness</span>: <span class="string">'Extreme'</span>, <span class="attr">hair</span>: <span class="string">'Brown'</span>, <span class="attr">eyes</span>: <span class="string">'Blue'</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> summary = &#123;...person, ...tools, ...attributes&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Object &#123;</span></span><br><span class="line"><span class="comment">  "computer": "Mac",</span></span><br><span class="line"><span class="comment">  "editor": "Atom",</span></span><br><span class="line"><span class="comment">  "eyes": "Blue",</span></span><br><span class="line"><span class="comment">  "gender": "Male",</span></span><br><span class="line"><span class="comment">  "hair": "Brown",</span></span><br><span class="line"><span class="comment">  "handsomeness": "Extreme",</span></span><br><span class="line"><span class="comment">  "name": "David Walsh",</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>　　这三个点让任务变得简单多！</p><h2 id="需要函数传参"><a href="#需要函数传参" class="headerlink" title="需要函数传参"></a>需要函数传参</h2><p>　　能够为函数参数设置默认值是<code>JavaScript</code>的一个很棒的补充。但请查看这个技巧，<a href="https://davidwalsh.name/javascript-function-parameters" target="_blank" rel="noopener">要求为给定的参数传递值</a> :</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isRequired = <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'param is required'</span>); &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> hello = <span class="function">(<span class="params">name = isRequired(</span>)) =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">`hello <span class="subst">$&#123;name&#125;</span>`</span>) &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于没给 hello() 传 name，该代码会报错</span></span><br><span class="line">hello();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面代码也会报错</span></span><br><span class="line">hello(<span class="literal">undefined</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 来看看符合要求的写法</span></span><br><span class="line">hello(<span class="literal">null</span>);</span><br><span class="line">hello(<span class="string">'David'</span>);</span><br></pre></td></tr></table></figure><p>　　这是一些下一级的验证和<code>JavaScript</code>的用法！</p><h2 id="解构别名"><a href="#解构别名" class="headerlink" title="解构别名"></a>解构别名</h2><p>　　<a href="https://davidwalsh.name/destructuring-alias" target="_blank" rel="noopener">解构赋值</a>是一个非常受欢迎的<code>JavaScript</code>升级，但有时我们更喜欢用其他名称引用这些属性，所以我们可以利用别名：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Grabs obj.x as &#123; x &#125;</span></span><br><span class="line"><span class="keyword">const</span> &#123; x &#125; = obj;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Grabs obj.x as &#123; otherName &#125;</span></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">x</span>: otherName &#125; = obj;</span><br></pre></td></tr></table></figure><p>　　有效避免了与现有变量的命名冲突！</p><h2 id="获取查询字符串参数"><a href="#获取查询字符串参数" class="headerlink" title="获取查询字符串参数"></a>获取查询字符串参数</h2><p>　　多年来，我们编写了大量正则表达式来获取查询字符串值，但那些日子已经一去不复返了——我们拥有了令人惊叹的 <a href="https://davidwalsh.name/query-string-javascript" target="_blank" rel="noopener">URLSearchParams</a> API:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设 "?post=1234&amp;action=edit"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> urlParams = <span class="keyword">new</span> URLSearchParams(<span class="built_in">window</span>.location.search);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(urlParams.has(<span class="string">'post'</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(urlParams.get(<span class="string">'action'</span>)); <span class="comment">// "edit"</span></span><br><span class="line"><span class="built_in">console</span>.log(urlParams.getAll(<span class="string">'action'</span>)); <span class="comment">// ["edit"]</span></span><br><span class="line"><span class="built_in">console</span>.log(urlParams.toString()); <span class="comment">// "?post=1234&amp;action=edit"</span></span><br><span class="line"><span class="built_in">console</span>.log(urlParams.append(<span class="string">'active'</span>, <span class="string">'1'</span>)); <span class="comment">// "?post=1234&amp;action=edit&amp;active=1"</span></span><br></pre></td></tr></table></figure><p>　　是不是比之前简单多了！</p><p>　　这些年<code>JavaScript</code>已经发生了很大的变化，但我最喜欢的部分是我们现在看到<code>JavaScript</code>语言改进的速度。尽管 JavaScript 在不断动态变化，我们仍然需要使用一些不错的技巧;把这些技巧放在你的工具箱里，以备不时之需！</p><p>　　你最喜欢的<code>JavaScript</code>技巧是什么呢？<br>　　<strong><font color="red">以下为译文：</font></strong></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>　　<code>(…)</code>确实挺好用，也比较常用，有实际的体验。其它的小技巧有类似的经历，例如创建空对象，进行原型链的继承，但用的比较少。加油吧！</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> tricks </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解JavaScript中的null与undefined</title>
      <link href="/2019/10/20/understanding-null-and-undefined/"/>
      <url>/2019/10/20/understanding-null-and-undefined/</url>
      
        <content type="html"><![CDATA[<h2 id="关于null"><a href="#关于null" class="headerlink" title="关于null"></a>关于null</h2><p>　　<code>null</code>值表示一个指向不存在或无效的对象或地址 (<a href="https://developer.mozilla.org/en-US/docs/Glossary/Null" target="_blank" rel="noopener">DMN</a>) 引用。即使它指向不存在的东西，它是一个全局对象(也是 JavaScript 的原始值之一)。<br>　　在浏览器中按<font color="black"> Ctrl+Shift+J (Windows / Linux) </font>或者<font color="black"> Cmd+Opt+J (Mac)</font>打开专用的 Console 面板，在控制台中键入 typeof null，返回 “object”：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">typeof</span> <span class="literal">null</span></span><br><span class="line">&lt; <span class="string">"object"</span></span><br></pre></td></tr></table></figure><p>　　否定<code>null</code>值返回<code>true</code>，但将其与<code>false</code>(或<code>true</code>)进行比较则会返回<code>false</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; !<span class="literal">null</span></span><br><span class="line">&lt; <span class="literal">true</span></span><br><span class="line">&gt; <span class="literal">null</span> == flase</span><br><span class="line">&lt; <span class="literal">false</span></span><br><span class="line">&gt; <span class="literal">null</span> === flase</span><br><span class="line">&lt; <span class="literal">false</span></span><br><span class="line">&gt; <span class="literal">null</span> == <span class="literal">true</span></span><br><span class="line">&lt; <span class="literal">false</span></span><br><span class="line">&gt; <span class="literal">null</span> === <span class="literal">true</span></span><br><span class="line">&lt; <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>　　当进行基础的数学运算时，<code>null</code>值转换为<code>0</code>。甚至<code>null + null</code>也为<code>0</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="literal">null</span> + <span class="number">2</span></span><br><span class="line">&lt; <span class="number">5</span></span><br><span class="line">&gt; <span class="literal">null</span> - <span class="number">2</span></span><br><span class="line">&lt; <span class="number">-2</span></span><br><span class="line">&gt; <span class="literal">null</span> * <span class="number">2</span></span><br><span class="line">&lt; <span class="number">0</span></span><br><span class="line">&gt; <span class="literal">null</span> / <span class="number">2</span></span><br><span class="line">&lt; <span class="number">0</span></span><br><span class="line">&gt; <span class="literal">null</span> % <span class="number">2</span></span><br><span class="line">&lt; <span class="number">0</span></span><br><span class="line">&gt; <span class="literal">null</span> + <span class="literal">null</span></span><br><span class="line">&lt; <span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="关于undefined"><a href="#关于undefined" class="headerlink" title="关于undefined"></a>关于undefined</h2><p>　　全局属性<code>undefined</code>表示原始值 <code>undefined</code>。它也是 JavaScript 的原始数据类型 (<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined" target="_blank" rel="noopener">MDN</a>)。<code>undefined</code>是全局作用域的一个变量。<code>undefined</code>的最初值就是原始数据类型<code>undefined</code>。一个没有被赋值的变量的类型是<code>undefined</code>。如果方法或者是语句中操作的变量没有被赋值，则会返回<code>undefined</code>。<br>　　在浏览器中按<font color="black"> Ctrl+Shift+J (Windows / Linux) </font>或者<font color="black"> Cmd+Opt+J (Mac)</font>打开专用的 Console 面板，在控制台中键入 typeof undefined，返回 “undefined”：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">typeof</span> <span class="literal">undefined</span></span><br><span class="line">&lt; <span class="string">"undefined"</span></span><br></pre></td></tr></table></figure><p>　　当声明一个变量但没有赋值时，JavaScript 会给它赋值为<code>undefined</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">var</span> a</span><br><span class="line">&lt; <span class="literal">undefined</span></span><br><span class="line">&gt; a</span><br><span class="line">&lt; <span class="literal">undefined</span></span><br></pre></td></tr></table></figure><p>　　与<code>null</code>相似，否定<code>undefined</code>值返回<code>true</code>，但将其与<code>true</code>或<code>false</code>作比较则返回<code>false</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; !<span class="literal">undefined</span></span><br><span class="line">&lt; <span class="literal">true</span></span><br><span class="line">&gt; <span class="literal">undefined</span> == flase</span><br><span class="line">&lt; <span class="literal">false</span></span><br><span class="line">&gt; <span class="literal">undefined</span> === flase</span><br><span class="line">&lt; <span class="literal">false</span></span><br><span class="line">&gt; <span class="literal">undefined</span> == <span class="literal">true</span></span><br><span class="line">&lt; <span class="literal">false</span></span><br><span class="line">&gt; <span class="literal">undefined</span> === <span class="literal">true</span></span><br><span class="line">&lt; <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>　　且当在任何运算中使用<code>undefined</code>时，会返回<code>NaN</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="literal">undefined</span> + <span class="number">2</span></span><br><span class="line">&lt; <span class="literal">NaN</span></span><br><span class="line">&gt; <span class="literal">undefined</span> - <span class="number">2</span></span><br><span class="line">&lt; <span class="literal">NaN</span></span><br><span class="line">&gt; <span class="literal">undefined</span> * <span class="number">2</span></span><br><span class="line">&lt; <span class="literal">NaN</span></span><br><span class="line">&gt; <span class="literal">undefined</span> / <span class="number">2</span></span><br><span class="line">&lt; <span class="literal">NaN</span></span><br><span class="line">&gt; <span class="literal">undefined</span> % <span class="number">2</span></span><br><span class="line">&lt; <span class="literal">NaN</span></span><br><span class="line">&gt; <span class="literal">undefined</span> + <span class="literal">undefined</span></span><br><span class="line">&lt; <span class="literal">NaN</span></span><br></pre></td></tr></table></figure><h2 id="null-VS-undefined"><a href="#null-VS-undefined" class="headerlink" title="null VS undefined"></a>null VS undefined</h2><p>　　那么<code>null</code>与<code>undefined</code>两者之间有什么区别呢？通过上面的内容，我们来比较一下它们之间的相似点和不同之处。<br>　　<strong><font color="black">相似点：</font></strong><br>　　1. 当被否定时，两者的值都是<code>true</code>。<br>　　2. 代表一些不存在的东西。<br>　　<strong><font color="black">不同之处：</font></strong><br>　　1. <code>null</code>表示无，完全不存在；<code>undefined</code>表示没有定义<br>　　2. <code>undefined</code>有自己的数据类型( undefined )，<code>null</code>只是一个对象<br>　　3. 在基本算数运算汇总，<code>null</code>被当做<code>0</code>，<code>undefined</code>返回的是<code>NaN</code><br>　　需要注意的是<code>undefined == null</code>返回的值是<code>true</code> ，因为JavaScript会尽力将两者转为相同的类型。而<code>!undefined == !null</code>与<code>!undefined === !null</code>返回<code>true</code>，以及为何有开发者喜欢用<code>!null</code>进行逻辑判断也不难理解了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="literal">undefined</span> == <span class="literal">null</span></span><br><span class="line">&lt; <span class="literal">true</span></span><br><span class="line">&gt; <span class="literal">undefined</span> === <span class="literal">null</span></span><br><span class="line">&lt; <span class="literal">false</span></span><br><span class="line">&gt; !<span class="literal">undefined</span> == !<span class="literal">null</span></span><br><span class="line">&lt; <span class="literal">true</span></span><br><span class="line">&gt; !<span class="literal">undefined</span> === !<span class="literal">null</span></span><br><span class="line">&lt; <span class="literal">true</span></span><br><span class="line">&gt; <span class="keyword">typeof</span> <span class="literal">null</span></span><br><span class="line">&lt; <span class="string">"object"</span></span><br><span class="line">&gt; <span class="keyword">typeof</span> <span class="literal">undefined</span></span><br><span class="line">&lt; <span class="string">"undefined"</span></span><br><span class="line">&gt; <span class="keyword">typeof</span> !<span class="literal">null</span></span><br><span class="line">&lt; <span class="string">"boolean"</span></span><br><span class="line">&gt; <span class="keyword">typeof</span> !<span class="literal">undefined</span></span><br><span class="line">&lt; <span class="string">"boolean"</span></span><br><span class="line">&gt; !<span class="literal">null</span></span><br><span class="line">&lt; <span class="literal">true</span></span><br><span class="line">&gt; !<span class="literal">undefined</span></span><br><span class="line">&lt; <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>　　<code>null</code>表示无、不存在或无效的对象或地址引用。它在简单的数学运算中会转换为<code>0</code>，它是一个全局对象。<code>null == false</code>返回的值是<code>false</code>。<br>　　<code>undefined</code>是一个全局属性，原始值<code>undefined</code>。它表示有些东西没有赋值，未定义。<code>undefined</code> 不能转换成数字，因此在数学计算中使用它，返回的是<code>NaN</code>。<br>　　<strong><code>注：</code></strong> 编程规范中尽量用<code>void 0</code>代替 <code>undefined</code>。另外<code>NaN</code>表示一个不是数字的东西，尽管它实际上是一个数字(<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN" target="_blank" rel="noopener">MDN</a>)。它不等于本身，要检查是否有东西是<code>NaN</code>时，可借助 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/isNaN" target="_blank" rel="noopener">isNaN()</a> 函数。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> null与undefined </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo小站搭建</title>
      <link href="/2019/10/14/hexo-build/"/>
      <url>/2019/10/14/hexo-build/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>　　其实平时自己并不怎么写文章，不过有看到一些东西会做笔记的习惯，但是每次写的东西都会到处放，不好找，所以想着自己搭建一个人博客网站。hexo比较平民化，并且能使用的主题也很多，所以就用它啦~<br>　　自己搭建完了也写一篇文章总结下，方便以后有需要看看。（.ps：本小站是在Windows系统下搭建）</p><h2 id="安装Git-Bash"><a href="#安装Git-Bash" class="headerlink" title="安装Git Bash"></a>安装Git Bash</h2><p>　　Windows：到git官网上下载，<a href="https://gitforwindows.org/" target="_blank" rel="noopener">Download git</a> (附链接)。<br>　　安装步骤：双击下载好的.exe文件，一直next就行了，安装完后会有一个Git Bash的命令行工具。<br>　　安装好后：打开Git Bash，键入命令 <font color="red">git –version</font> 来查看一下版本，用来确认是否安装成功。</p><h2 id="安装NodeJs"><a href="#安装NodeJs" class="headerlink" title="安装NodeJs"></a>安装NodeJs</h2><p>　　Windows：到Node.js官网上下载，<a href="https://nodejs.org/en/" target="_blank" rel="noopener">Download NodeJs</a> (附链接)。<br>　　安装步骤：双击下载好.msi文件，也是一路next就行了，最好在Custom Setup这一步选择 <font color="blue">Add to PATH</font> 。<br>　　安装完后：打开命令行，键入命令 <font color="red">node -v</font> 来查看一下版本，用来确认是否安装成功。</p><h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><p>　　前面Git和NodeJs安装好后，就可以安装hexo了。先创建一个文件夹blog，然后cd到这个文件夹下（或者在这个文件夹下直接右键Git Bash打开）。<br>　　键入命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>　　安装完成后：键入命令 <font color="red">hexo -v</font> 来查看一下版本，用来确认是否安装成功。</p><p>　　然后初始化hexo，键入命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure><p>　　初始化完成后，打开所在的文件夹可以看到以下文件夹等：</p><div class="note no-icon">            <p>　　<em>node_modules: 依赖包<br>　　public：存放生成的页面<br>　　scaffolds：生成文章的一些模板<br>　　source：用来存放你的文章<br>　　themes：主题<br>　　config.yml: 博客的配置文件<br>　　db.json：source解析所得到的<br>　　package.json：项目所需模块项目的配置信息</em></p>          </div><p>　　此时，键入命令打开hexo服务就可以生成博客了。<br>　　输入命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>　　在浏览器输入localhost:4000就可以看到你生成的博客啦（如果没有也没关系，往下看就行了），可以使用crtl+c把服务关掉。(.ps：不过这只是在本地噢，要想生成线上的，还需要接下来的步骤。)</p><h2 id="生成SSH并添加到github"><a href="#生成SSH并添加到github" class="headerlink" title="生成SSH并添加到github"></a>生成SSH并添加到github</h2><p>　　首先，你先要有一个GitHub账户，没有的话去注册一个吧。注册完登录后，在github.com中鼠标移至『<strong>＋</strong>』看到一个New repository，新建仓库。<br>　　创建一个和你用户名相同的仓库，名称为yourname.github.io, 其中yourname是你的github名称。点击create repository后，回到git bash中，配置github账户信息（YourName和YourEail都替换成你自己的）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name "yourname"</span><br><span class="line">git config --global user.email "youremail"</span><br></pre></td></tr></table></figure><p>　　怕自己输错的可以键入命令检查一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config user.name</span><br><span class="line">git config user.email</span><br></pre></td></tr></table></figure><p>　　确认没错后，创建SSH，一路回车：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C "youremail"</span><br></pre></td></tr></table></figure><p>　　然后按输出的路径找到id_rsa.pub文件，一般在C:\Users\user(用户名).ssh目录下。用编辑器打开<strong><font color="red">rsa.pub</font></strong>文件，将里面的内容复制到github<strong><font color="red">设置</font></strong>中的<strong><font color="red">SSH and GPG keys</font></strong>。<br>　　添加一个 New SSH key ，title随便取，key就填刚刚那一段。<br>　　在git bash中验证是否添加成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><h2 id="部署项目并上传到github"><a href="#部署项目并上传到github" class="headerlink" title="部署项目并上传到github"></a>部署项目并上传到github</h2><p>　　打开你的blog项目，修改_config.yml站点文件的一些配置，YourgithubName就是你的GitHub账户(另外要注意冒号之后都是有一个半角空格的)：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">  repo:</span> <span class="attr">https://github.com/YourgithubName/YourgithubName.github.io.git</span></span><br><span class="line"><span class="attr">  branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>　　回到gitbash中，进入你的blog目录，安装deploy-git，也就是部署的命令,这样你才能用命令部署到GitHub。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>　　然后分别执行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure><div class="note no-icon">            <p>　　<em>hexo clean清除了你之前生成的东西，也可以不加。<br>　　hexo generate 顾名思义，生成静态文章，可以用 hexo g缩写<br>　　hexo deploy 部署文章，可以用hexo d缩写<br>　　注意deploy时可能要你输入username和password</em></p>          </div><p>　　在浏览器中输入 <em><a href="http://yourgithubname.github.io" target="_blank" rel="noopener">http://yourgithubname.github.io</a></em> 就可以看到你的个人博客啦，是不是很兴奋！<br>　　至此，小站就搭建完成啦，如果不想绑定个人域名的，可以自行跳到『<font color="black"><strong>修改及配置主题</strong></font>』，查看如何进行修改及配置主题。</p><h2 id="绑定个人域名"><a href="#绑定个人域名" class="headerlink" title="绑定个人域名"></a>绑定个人域名</h2><p>　　第一步，注册阿里云账户，在阿里云上买一个域名，各个后缀的价格不太一样，比如最广泛的.com就较贵。<br>　　第二步，添加CNAME，在项目的source文件夹下新建一个名为CNAME的文件，没有后缀名。在里面添加你购买的域名，比如我添加的是leedv.site，只能添加一个哦。(.ps：可以创建个.txt文件，键入内容后把后缀名删掉。)<br>　　第三步，在阿里云 <font color="red"><strong>域名控制台</strong></font>  中，找到你购买的域名。点 <font color="red"><strong>解析</strong></font> 进去，添加解析(两条)。</p><div class="note no-icon">            <p>　　<em>记录类型均为 <strong>A</strong><br>　　主机类型为 <strong>＠</strong> 以及 <strong>www</strong><br>　　解析线路为 <strong>默认</strong><br>　　记录值为 <strong>自己的博客 ip 地址</strong><br>　　(博客ip地址可通过ping命令获得，在cmd命令行中输入 ping yourgithubname.github.io 即可获得 ip 地址)</em></p>          </div><p>　　第四步，登录GitHub，进入之前创建的仓库，点击settings，设置 Custom domain ，输入你的域名 leedv.site 。<br>　　最后，在gitbash中，分别输入命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>　　部署完之后，打开浏览器，输入自己的域名，就可以看到搭建的网站博客啦！<br>　　至此，hexo小站搭建完成。</p><h2 id="安装-butterfly-主题"><a href="#安装-butterfly-主题" class="headerlink" title="安装 butterfly 主题"></a>安装 butterfly 主题</h2><p>　　hexo初始化之后默认的主题是landscape，当然，如果想要更换自己喜欢的主题，可以去<a href="https://hexo.io/themes/" target="_blank" rel="noopener">hexo官网</a>挑选，在github中搜索你要的主题名称，里面都会有该主题的如何使用的介绍，按着来就好了，反正就是改改改！我选的是 <font color="red"><strong>butterfly</strong></font> 。<br>　　在博客根目录安装主题</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/Butterfly</span><br></pre></td></tr></table></figure><p>　　安装渲染器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-renderer-jade hexo-renderer-stylus --save</span><br></pre></td></tr></table></figure><p>　　修改hexo配置文件_config.yml，把主题改为Butterfly</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">Butterfly</span></span><br></pre></td></tr></table></figure><p>　　其余配置请参考主题的<a href="https://docs.jerryc.me/" target="_blank" rel="noopener">配置文档</a>(附链接)，里面很详细，不用担心！(.ps：文档中所说的butterfly.xml其实就是Butterfly文件中的_config.yml，大家放心去用吧 :) )</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>　　卡住了就让卡住吧，休息一会儿你会发现新大陆的。</p>]]></content>
      
      
      <categories>
          
          <category> 小站搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo小站 </tag>
            
            <tag> 小站搭建 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
